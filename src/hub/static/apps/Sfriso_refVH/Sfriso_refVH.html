<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Carimbar</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<script type="text/javascript">

function getParameterByName(name,url){
 name=name.replace(/[\[\]]/g,"\\$&");
 var regex=new RegExp("[?&]"+name+"(=([^&#]*)|&|#|$)"),
  results=regex.exec(url);
 if(!results) return null;
 if(!results[2]) return '';
 return decodeURIComponent(results[2].replace(/\+/g," "));
}
function parseData(){
 var u=window.location.href,num,nAzu;
 num=getParameterByName("num",u)
 nAzu=parseInt(num);
 return nAzu
}

if (!Array.from) {
  Array.from = (function () {
    var toStr = Object.prototype.toString;
    var isCallable = function (fn) {
      return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
    };
    var toInteger = function (value) {
      var number = Number(value);
      if (isNaN(number)) { return 0; }
      if (number === 0 || !isFinite(number)) { return number; }
      return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
    };
    var maxSafeInteger = Math.pow(2, 53) - 1;
    var toLength = function (value) {
      var len = toInteger(value);
      return Math.min(Math.max(len, 0), maxSafeInteger);
    };

    // The length property of the from method is 1.
    return function from(arrayLike/*, mapFn, thisArg */) {
      // 1. Let C be the this value.
      var C = this;

      // 2. Let items be ToObject(arrayLike).
      var items = Object(arrayLike);

      // 3. ReturnIfAbrupt(items).
      if (arrayLike == null) {
        throw new TypeError("Array.from requires an array-like object - not null or undefined");
      }

      // 4. If mapfn is undefined, then let mapping be false.
      var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
      var T;
      if (typeof mapFn !== 'undefined') {
        // 5. else
        // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.
        if (!isCallable(mapFn)) {
          throw new TypeError('Array.from: when provided, the second argument must be a function');
        }

        // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.
        if (arguments.length > 2) {
          T = arguments[2];
        }
      }

      // 10. Let lenValue be Get(items, "length").
      // 11. Let len be ToLength(lenValue).
      var len = toLength(items.length);

      // 13. If IsConstructor(C) is true, then
      // 13. a. Let A be the result of calling the [[Construct]] internal method of C with an argument list containing the single item len.
      // 14. a. Else, Let A be ArrayCreate(len).
      var A = isCallable(C) ? Object(new C(len)) : new Array(len);

      // 16. Let k be 0.
      var k = 0;
      // 17. Repeat, while k < len. (also steps a - h)
      var kValue;
      while (k < len) {
        kValue = items[k];
        if (mapFn) {
          A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
        } else {
          A[k] = kValue;
        }
        k += 1;
      }
      // 18. Let putStatus be Put(A, "length", len, true).
      A.length = len;
      // 20. Return A.
      return A;
    };
  }());
}


function parseData2(){
 var u=window.location.href,lis;
 lis=getParameterByName("lis",u)
 return lis
}
</script>
	<style type="text/css">
html {
  width: 100%;
  height: 100%;
   margins:0 px;
  background: #fae47b;  
}
</style>	
<style type="text/css">
/* Tooltip container */
.tooltip {
    position: relative;
    display: inline-block;
   
}

/* Tooltip text */
.tooltip .tooltiptext {
    visibility: hidden;
    width: 162px;
    background-color: #555;
    color: #fff;
    text-align: center;
    padding: 5px 20px;
    border-radius: 6px;
	font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 12px;

    /* Position the tooltip text */
    position: absolute;
    z-index: 1;
    bottom: -210%;
    left: 0%;

    /* Fade in tooltip */
    opacity: 0;
    transition: opacity 0.3s;
}

/* Tooltip arrow */
.tooltip .tooltiptext::after {
    content: "";
    position: absolute;
    top: -25%;
    left: 0%;
    margin-left: 6px;
    border-width: 5px;
    border-style: solid;
    border-color:  transparent transparent  #555  transparent;
}

/* Show the tooltip text when you mouse over the tooltip container */
.tooltip:hover .tooltiptext {
    visibility: visible;
    opacity: 1;
}

</style>
<link rel="stylesheet" type="text/css" href="../atractor-apps-all/csss/style1.css">
	
	<script>
	
nAzu=parseData();
	
	
	
	function myFunction(image){
    var img = new Image();
    img.src = image;
    img.onload = function() {   
         a=this.width/this.height;
		 return a
        
}}

var imgname = "../atractor-apps-all/imgs/mot"+parseInt(nAzu)+".png";

var a = myFunction(imgname)

</script>
</head>
	<body onload="init();animate();return false">

	<div id="THREE" style="position:absolute; top: 0px;"></div>


<img  src="../atractor-apps-all/icons/pause.png"  width=3.5% id=pauseRotateButton onClick=pauseRotation() style="position:absolute;  top: 8px;"></img>
<img  src="../atractor-apps-all/icons/play.png"  width=3.5% id=playRotateButton onClick=playRotation() style="position:absolute; top: 8px; display: none;"></img>



<input type="range" name="RangeVal" value="RangeVal" id="range" min="-2.5" max="11.5" step=".1" style="position:absolute;  top: 13px;  left:50px; "  />


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<img src="../atractor-apps-all/icons/back.png" width=2.5% onclick="home();" style="position:absolute;  top: 10px; left:300px"></img>



<script type="text/javascript" src="../atractor-apps-all/scripts/three87.js"></script>
<script type="text/javascript" src="../atractor-apps-all/scripts/Detector.js"></script>
<script type="text/javascript" src="../atractor-apps-all/scripts/TrackballControls.js"></script>
<script type="text/javascript" src="../atractor-apps-all/scripts/jquery.min.js"></script>
<script type="text/javascript" src="../atractor-apps-all/scripts/jquery-ui.min.js"></script>
	
<script type="text/javascript">
	

function home(){
	window.location.href='index.html'
}


		
			function increaseValue(value,increment)
{
 value = value * increment;
 animate();
 return speed=value
}

var speed=0.01	

var nn=2; 
var initv = 0;
		
var material = new THREE.MeshLambertMaterial( { map: new THREE.TextureLoader().load(imgname) ,side: THREE.DoubleSide} );
		
			
var materialF = new THREE.MeshLambertMaterial( { map: new THREE.TextureLoader().load(imgname) ,
        side: THREE.FrontSide,
        flatShading: true,
        transparent: true,
        opacity: 0.9
    } );	

var materialB = new THREE.MeshLambertMaterial( { map: new THREE.TextureLoader().load(imgname) ,
        side: THREE.BackSide,
        flatShading: true,
        transparent: true,
        opacity: 0.9
    } );		


		texturep = new THREE.TextureLoader().load(imgname);


// assuming you want the texture to repeat in both directions:
texturep.wrapS = THREE.MirroredRepeatWrapping; 
texturep.wrapT = THREE.MirroredRepeatWrapping;

// how many times to repeat in each direction; the default is (1,1),
//   which is probably why your example wasn't working
if(nn==1) {texturep.repeat.set(6, 1 )} else {texturep.repeat.set(6*nn+1, 1 )}; 	

var materialp = new THREE.MeshLambertMaterial( { map: texturep ,side: THREE.DoubleSide} );

var materialtap = new THREE.MeshBasicMaterial( { color : 0xf3f1cd,  side:THREE.DoubleSide } );

		
		var RangeVal=-2.5;
			var camera, scene, renderer, controls,  kc, tempo;
			var mesh;
			var meshFunction;
			var xMin = -a;
			var xMax = a;
			var yMin = -1;
			var yMax = 1;
			var segments = 40;
			var tapete;
			var tapete2;
var vira =-1;
var h_plane = -0.0018;
var h_pad = 0.00021;
var h_tap = h_plane+0.00031;

function phi(tt) {return Math.pow(tt-11.5,5)+11.5}


		range.oninput = function() {
    var tt = this.value;
	RangeVal=parseFloat(this.value);
	
	if(tt<10.5)    {var kc = 4*a*nn

				camera.fov = 16;
camera.updateProjectionMatrix();
				camera.position.set(3.4*kc,3.4*kc,5.6*kc);
						
				camera.lookAt(new THREE.Vector3(0,3,0));
				camera.up.set(0,55,0)}
	
	 if(tt<3.51) {displaySup(tt*nn,0)} else {if(tt<4.5) 
	 {vira=-1;displaySupReflect(3.5*nn, (tt-0.5)%1)} else
	 if(tt<10.5){vira=1;displaySup(nn*(-tt+8),1)} else 
	 {vira=1;displaySup(nn*(-10.5+8),1)
	 
	 scene.remove(mesh)
var kc = 4*a*nn


camera.fov = 16*(1-phi(tt)+10.5)+32*(phi(tt)-10.5);
camera.updateProjectionMatrix();
			

				camera.position.set(3.4*kc*(1-phi(tt)+10.5),
				3.4*kc,0.01*(phi(tt)-10.5)+5.6*kc*(1-phi(tt)+10.5));
						
				camera.lookAt(new THREE.Vector3(0,3,0));
				camera.up.set(0,55,0)
				renderer.render( scene, camera )
	 
	 }
	 ;};
	 
	 if(tt==11.5) {
		isRotating=false;initv=1;
document.getElementById("pauseRotateButton").style.display='none';
document.getElementById("playRotateButton").style.display='inline';
pauseRotateButton.innerHTML="Animar";RangeVal=-2.5;} 

}
range.onchange = function() {var tt = this.value;
	RangeVal=parseFloat(this.value);
	
	if(tt<10.5)    {var kc = 4*a*nn

				camera.fov = 16;
camera.updateProjectionMatrix();
				camera.position.set(3.4*kc,3.4*kc,5.6*kc);
						
				camera.lookAt(new THREE.Vector3(0,3,0));
				camera.up.set(0,55,0)}
				
	 if(tt<3.51) {displaySup(tt*nn,0)} else {if(tt<4.5) 
	 {vira=-1;displaySupReflect(3.5*nn, (tt-0.5)%1)} else
	 if(tt<10.5){vira=1;displaySup(nn*(-tt+8),1)} else 
	 {vira=1;displaySup(nn*(-10.5+8),1)
	 
	 scene.remove(mesh)
var kc = 4*a*nn
camera.fov = 16*(1-phi(tt)+10.5)+32*(phi(tt)-10.5);
camera.updateProjectionMatrix();
				camera.position.set(3.4*kc*(1-phi(tt)+10.5),
				3.4*kc,0.01*(phi(tt)-10.5)+5.6*kc*(1-phi(tt)+10.5));
						
				camera.lookAt(new THREE.Vector3(0,3,0));
				camera.up.set(0,55,0)
				renderer.render( scene, camera )
	 
	 }
	 ;};
	 
	 
	 
	 if(tt==11.5) {
		isRotating=false;initv=1;
document.getElementById("pauseRotateButton").style.display='none';
document.getElementById("playRotateButton").style.display='inline';
pauseRotateButton.innerHTML="Animar";RangeVal=-2.5;} 
	 }



function reini() {initv=1};
			
			function init() {
			RangeVal=-2.51;
				// CENARIO + PROCESSAMENTO DE IMAGEM WEBGL
 				var loader = new THREE.TextureLoader();
loader.load('../atractor-apps-all/imgs/symm-bg4-02.jpg' , 
function(texture)
            {
             scene.background = texture;  
            });

				// CENA + PROCESSAMENTO DE IMAGEM WEBGL 
				scene = new THREE.Scene();
				renderer = new THREE.WebGLRenderer();
				
				
					       var width0=window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
var height0=window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
var width=.99*width0;
var height=.99*Math.min(width0/2,height0);
var width2=width;
var height2=height;
renderer.setSize(width,height);


document.getElementById('THREE').appendChild( renderer.domElement );
				renderer.setClearColor(0xfae47b,1);
				
				
				// CAMERA
				var aspect=width/height, near=5, far=2000;
				camera = new THREE.PerspectiveCamera(10,aspect,near,far);
				kc = 5*a*nn
				
				camera.position.set(3.4*kc,3.4*kc,5.6*kc);
						
				camera.lookAt(new THREE.Vector3(0,3,0));
				camera.up.set(0,55,0)
					
				// LUZES
				var light = new THREE.PointLight(0xffffff);
light.position.set(-25,25,-50);
//scene.add(light);
				var light2 = new THREE.PointLight(0xffffff);
				light2.position.set(-20,20,0);
				//scene.add(light2);
var lighta = new THREE.AmbientLight( 0xf0f0f0 ); // soft white light
scene.add( lighta );

controls = new THREE.TrackballControls( camera, renderer.domElement );
	controls.noPan = true;


				this.mesh = new THREE.Object3D(); 
				
mesh = Sup(0)
			  
				scene.add( mesh );
				
				

if(nn==1) {planef = new THREE.Mesh(new THREE.PlaneGeometry(6*2*a, 2), materialp)} else 
{planef = new THREE.Mesh(new THREE.PlaneGeometry((6*nn+1)*2*a, 2), materialp)};


planef.side = THREE.DoubleSide;
planef.material.side = THREE.DoubleSide;
planef.position.z = h_plane;


var translation = new THREE.Matrix4().makeTranslation(a*(nn-1),0,0);

planef.applyMatrix(translation)

planef.rotation.x = -Math.PI/2;
planef.position.z=1;
planef.position.y = h_plane;
scene.add(planef);

if(nn==1) {planefc = new THREE.Mesh(new THREE.PlaneGeometry(6*2*a, 2), materialp)} else 
{planefc = new THREE.Mesh(new THREE.PlaneGeometry((6*nn+1)*2*a, 2), materialp)};
planefc.side = THREE.DoubleSide;
planefc.material.side = THREE.DoubleSide;
planefc.position.z = h_plane;


var translation = new THREE.Matrix4().makeTranslation(a*(nn-1),0,0);

planefc.applyMatrix(translation)

planefc.rotation.x = -Math.PI/2;
planefc.position.z=-1;
planefc.position.y = h_plane;
planefc.scale.y=-1;
scene.add(planefc);
			
			var planeff = new THREE.Mesh(new THREE.PlaneGeometry((6*nn+1)*2*a+1, 4+1), materialtap);
planeff.side = THREE.DoubleSide;
planeff.material.side = THREE.DoubleSide;

planeff.position.y = -.006;
planeff.position.x=a

planeff.rotation.x = -Math.PI/2;
scene.add(planeff);
				
				// INSERIR EVENTO onWindowResize()
window.addEventListener('resize', function() {
        var width0=window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
var height0=window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
var width=.99*width0;
var height=.99*Math.min(width0/2,height0);
var width2=width;
var height2=height;
camera.aspect=width/height;
camera.updateProjectionMatrix();
renderer.setSize(width,height);
      });
renderer.render( scene, camera );
			}

			


function animate() {requestAnimationFrame(animate);
render();}

function render() {
		
	if(initv==1&&isRotating) {RangeVal = -2.5;
	tt=-2.5;
	
	document.getElementById('range').value = -2.5;
	vira=-1;
tempo=[];
tempoc=[];
tempoF=[];
tempocF=[];
minc=-2.5*nn;maxc=-2.5*nn;min=7;max=7;
scene.remove(tapete);scene.remove(tapete2);
displaySup(-2.5*nn,0); 
initv=0;
 var kc = 4*a*nn

			camera.fov = 16;
camera.updateProjectionMatrix();
				camera.position.set(3.4*kc,3.4*kc,5.6*kc);
						
				camera.lookAt(new THREE.Vector3(0,3,0));
				camera.up.set(0,55,0)
 isRotating=true;pauseRotateButton.innerHTML="Parar Animação";
 }
	
else {			
				
	if(isRotating)
    { 
	
	scene.remove(mesh);
	RangeVal += 0.01;
tt=Math.min(RangeVal,11.5);
	
	    document.getElementById('range').value = tt;
		
if(tt<10.5)    {var kc = 4*a*nn

				camera.fov = 16;
camera.updateProjectionMatrix();
				camera.position.set(3.4*kc,3.4*kc,5.6*kc);
						
				camera.lookAt(new THREE.Vector3(0,3,0));
				camera.up.set(0,55,0)}
		
		 if(tt<3.51) {displaySup(tt*nn,0)} else 
		 {if(tt<4.5) {vira=-1;displaySupReflect(3.5*nn, (tt-0.5)%1)} 
		 else if(tt<10.5){vira=1;displaySup(nn*(-tt+8),1)} else
		 {vira=1;displaySup(nn*(-10.5+8),1)
	 
	 scene.remove(mesh)
var kc = 4*a*nn

				camera.fov = 16*(1-phi(tt)+10.5)+32*(phi(tt)-10.5);
camera.updateProjectionMatrix();

camera.position.set(3.4*kc*(1-phi(tt)+10.5),
				3.4*kc,0.01*(phi(tt)-10.5)+5.6*kc*(1-phi(tt)+10.5));
						
				camera.lookAt(new THREE.Vector3(0,3,0));
				camera.up.set(0,55,0)
				renderer.render( scene, camera )
	 };};
		 
		 
		   	  	 	  if(RangeVal>11.5) {isRotating=false;initv=1;
document.getElementById("pauseRotateButton").style.display='none';
document.getElementById("playRotateButton").style.display='inline';
					  
					  pauseRotateButton.innerHTML="Animar";RangeVal=-2.5;	    document.getElementById('range').value = -2.5;}

	  
	  }
			
}
		if(animvp) {	var pos= new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z )
	 
var posf=pos.clone().applyAxisAngle(new THREE.Vector3(0,1,0),speed/8) 
	 camera.position.set(posf.x,posf.y,posf.z);
	  	camera.lookAt(new THREE.Vector3(0,0,0));
				camera.up.set(0, 55, 0)
        camera.updateProjectionMatrix()
		}

		renderer.render( scene, camera );}
			
	
	

	
	
			function Sup(clock)
{

		
var placa0=new THREE.Group();		
			placa01 = new THREE.Mesh(new THREE.PlaneGeometry(2*a, 2), materialF);
placa01.side = THREE.DoubleSide;
//placa01.material.side = THREE.DoubleSide;
placa01.position.z = h_plane

placa0.add(placa01);

placa02 = new THREE.Mesh(new THREE.PlaneGeometry(2*a, 2), materialB);
placa02.side = THREE.DoubleSide;
//placa02.material.side = THREE.DoubleSide;
placa02.position.z = h_plane

placa0.add(placa02);

		
			

var geometryesp = new THREE.CylinderGeometry( .03,0.03,2, 40 );
var materialesp =new THREE.MeshStandardMaterial({ color: new THREE.Color (0xffffff), emissive: new THREE.Color (0xf0fff0), emissiveIntensity:.10,  metalness: 0, roughness: 0,  side : THREE.DoubleSide});
meshesp = new THREE.Mesh( geometryesp, materialesp );

meshesp.position.x=-a;



placa0.add( meshesp );

meshesp2 = new THREE.Mesh( geometryesp, materialesp );

meshesp2.position.x=a;



placa0.add( meshesp2 );

var geometryesp3 = new THREE.CylinderGeometry( .03,0.03,2*a, 40 );	
meshesp3 = new THREE.Mesh( geometryesp3, materialesp );

meshesp3.rotation.z=Math.PI/2;
meshesp3.position.y=1


placa0.add( meshesp3 );
									
						return placa0;
					
				};
				

tempo=[];
tempoc=[];
tempoF=[];
tempocF=[];





if(nn==1) {var total =[-2.5,-1.5,-.5,.5,1.5,2.5] } else {var total = Array.from(Array(6*nn+1), function(_,x) {return Math.round(x-2.5*nn)})};
minc=-2.5*nn;maxc=-2.5*nn;min=7;max=7;


function union_arrays (x, y) {
  var obj = {};
  for (var i = x.length-1; i >= 0; -- i)
     obj[x[i]] = x[i];
  for (var i = y.length-1; i >= 0; -- i)
     obj[y[i]] = y[i];
  var res = []
  for (var k in obj) {
    if (obj.hasOwnProperty(k))  // <-- optional
      res.push(obj[k]);
  }
  return res;
}


function displaySup(clock,clock2)
{
var clockt = Math.round(clock * 100) / 100;

	scene.remove(mesh);
	scene.remove(tapete);
	scene.remove(tapete2);
	

if(clock2>.5){min=Math.min(min,clockt);
max=Math.max(max,clockt);maxc=7;diffc=[];};

if(clock2<.5) {minc=Math.min(minc,clockt);
maxc=Math.max(maxc,clockt);};



tempoadd=Array.from({length:(max-min)*10+1},function(v,k) {return Math.round((k/10+min)*10)/10});
tempoaddc=Array.from({length:(maxc-minc)*10+1},function(v,k) {return Math.round((k/10+minc)*10)/10});




if(min!=max){ tempo= union_arrays( tempo, tempoadd)};
if(minc!=maxc){ tempoc= union_arrays( tempoc, tempoaddc)};
   
   tempoF=tempo.filter(function (item, pos) {return tempo.indexOf(item) == pos});
   tempocF=tempoc.filter(function (item, pos) {return tempoc.indexOf(item) == pos});
   

diff = total.filter(function(x) { return tempoF.indexOf(x) < 0 })
diffc = total.filter(function(x) { return tempocF.indexOf(x) < 0 })


					
	mesh = Sup (clock);
mesh.rotation.x = -Math.PI/2;
	var k3 = (clock-Math.floor(clock))*Math.PI
			var k4 = Math.floor(clock)*2*a
	 var translation = new THREE.Matrix4().makeTranslation(a, 0,0);
		   var rotation = new THREE.Matrix4().makeRotationX(-Math.PI/2);
var translation1 = new THREE.Matrix4().makeTranslation(k4, 0,0);
var rotation2 = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), Math.PI-k3);

var transformation = translation1.multiply(rotation2.multiply(rotation.multiply(translation)));

mesh.applyMatrix(transformation);


	mesh.position.z = 0;	 
if(clock2<.50)	{if(Math.abs(Math.floor(clock)%2)==Math.abs((nn-1)%3)) {mesh.scale.set(-1,1,1)} else {mesh.scale.set(1,1,1)};} 
else {if(Math.abs(Math.floor(clock)%2)==Math.abs((nn-1)%3)) {mesh.scale.set(-1,-1,1)} else {mesh.scale.set(1,-1,1)};};
if(clock2<.50)	{mesh.position.z = 1} else {mesh.position.z = -1};


	scene.add(mesh);
	
	
	



tapete = new THREE.Group();
	tapete2 = new THREE.Group();
	


	var tapete_geometry = new THREE.CubeGeometry( 6*2*a/6, 2, h_pad );
 
 for (i=0;i<diff.length;i++)
 {tapeteadd = new THREE.Mesh( tapete_geometry, materialtap );
		tapeteadd.position.z = h_tap;
		
		
		var translation = new THREE.Matrix4().makeTranslation(diff[i]*2*a-a,0,-1);

tapeteadd.applyMatrix(translation)

tapeteadd.rotation.x = -Math.PI/2;
tapeteadd.position.y=h_tap;

tapete.add(tapeteadd);}

scene.add(tapete);


 for (i=0;i<diffc.length;i++)
 {tapete2add = new THREE.Mesh( tapete_geometry, materialtap );
		tapete2add.position.z = h_tap;
		
		var translation2 = new THREE.Matrix4().makeTranslation(diffc[i]*2*a-a,0,1);

tapete2add.applyMatrix(translation2)

tapete2add.rotation.x = -Math.PI/2;

tapete2add.position.y=h_tap;
tapete2.add(tapete2add);}

if(vira==-1){scene.add(tapete2)};


}	

function displaySupReflect(clock,clock2)
{
min=Math.round(clock * 10) / 10;
max=Math.round(clock * 10) / 10;
minc=Math.round(clock * 10) / 10;
maxc=Math.round(clock * 10) / 10;

scene.remove(tapete);
	scene.remove(tapete2);
	


tempoadd=Array.from({length:(max-min)*10+1},function(v,k) {return Math.round((k/10+min)*10)/10});
tempoaddc=Array.from({length:(maxc-minc)*10+1},function(v,k) {return Math.round((k/10+minc)*10)/10});

if(clock2==1){tempo= union_arrays( tempo, tempoadd)};
if(clock2==0) {tempoc= union_arrays( tempoc, tempoaddc)};



   
   tempoF=tempo.filter(function (item, pos) {return tempo.indexOf(item) == pos});
   tempocF=tempoc.filter(function (item, pos) {return tempoc.indexOf(item) == pos});
   

diff = total.filter(function(x) { return tempoF.indexOf(x) < 0 })
diffc = total.filter(function(x) { return tempocF.indexOf(x) < 0 })

scene.remove(mesh);
mesh = Sup (clock);
mesh.position.z = 1
mesh.rotation.x = -Math.PI/2;
	var k3 = (.9999*clock2-Math.floor(.9999*clock2))*Math.PI
			var k4 = Math.round(clock)*2*a-a*(nn-1)
			 var translation = new THREE.Matrix4().makeTranslation(0, -1,0);
		   var rotation = new THREE.Matrix4().makeRotationX(-Math.PI/2);
var translation1 = new THREE.Matrix4().makeTranslation(k4, 0,0);
var rotation2 = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1,0,0), -k3);

var transformation = translation1.multiply(rotation2.multiply(rotation.multiply(translation)));

mesh.applyMatrix(transformation);


	//mesh.position.z = h_plane	 
if(Math.abs(Math.floor(clock)%2)==Math.abs((nn-1)%3)) {mesh.scale.set(1,1,1)} else {mesh.scale.set(-1,1,1)};
/*if(clock2<.50)	{mesh.position.z = 1} else {mesh.position.z = -1};
*/
	scene.add(mesh);
	
	tapete = new THREE.Group();
	tapete2 = new THREE.Group();
	
	var tapete_geometry = new THREE.CubeGeometry( 6*2*a/6, 2, h_pad );
 
 for (i=0;i<diff.length;i++)
 {tapeteadd = new THREE.Mesh( tapete_geometry, materialtap );
		tapeteadd.position.z = h_tap;
		
		
		var translation = new THREE.Matrix4().makeTranslation(diff[i]*2*a-a,0,-1);

tapeteadd.applyMatrix(translation)

tapeteadd.rotation.x = -Math.PI/2;

tapete.add(tapeteadd);}

scene.add(tapete);


 for (i=0;i<diffc.length;i++)
 {tapete2add = new THREE.Mesh( tapete_geometry, materialtap );
		tapete2add.position.z = h_tap;
		
		var translation2 = new THREE.Matrix4().makeTranslation(diffc[i]*2*a-a,0,1);

tapete2add.applyMatrix(translation2)

tapete2add.rotation.x = -Math.PI/2;

tapete2.add(tapete2add);}

//scene.add(tapete2);
	
	}



var isRotating=true
function pauseRotation()
{isRotating=false;
document.getElementById("pauseRotateButton").style.display='none';
document.getElementById("playRotateButton").style.display='inline';

 }


function playRotation()
{isRotating=true;
document.getElementById("pauseRotateButton").style.display='inline';
document.getElementById("playRotateButton").style.display='none';
}


var animvp=false;

var viewvar=false; 
function viewpoint()
{viewvar=!viewvar; 

if(viewvar) 
{

var kc = 5*a*nn

				camera.position.set(0,2*kc,0.01);
				camera.lookAt(new THREE.Vector3(0,0,0));
				camera.up.set(0,55,0)
				renderer.render( scene, camera )} 
else 
{
var kc = 5*a*nn
				camera.position.set(-2.4*kc,2*kc,1.3*kc);
			camera.lookAt(new THREE.Vector3(0,0,0));
				camera.up.set(0,55,0)
				renderer.render( scene, camera )
};}
		</script>

	</body>
</html>
